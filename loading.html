<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CA Scribe - Loading...</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Playfair+Display:ital,wght@1,600&display=swap"
    rel="stylesheet">
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #7dd3fc 0%, #bae6fd 100%);
      font-family: 'Inter', sans-serif;
      cursor: wait;
    }

    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #introCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #loading-label {
      position: absolute;
      top: 65%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      font-size: 16px;
      letter-spacing: 0.1em;
      color: #003B5C;
      opacity: 1;
      transition: opacity 0.5s;
      z-index: 2;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="introCanvas"></canvas>
    <div id="loading-label">LOADING...</div>
  </div>

  <script>
    // --- 1. CONFIG ---
    const CONFIG = {
        pingInterval: 500,
        targetUrl: 'http://localhost:8501',
        healthUrl: 'http://localhost:8501/_stcore/health',
        colors: { ca: '#003B5C', scribe: '#005F88', star: '#0ea5e9' }
    };
    
    // --- 2. SETUP CANVAS ---
    const canvas = document.getElementById('introCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();
    
    // --- 3. PARTICLE ENGINE (BATCHED) ---
    // Optimizations: Groups particles by color. Uses rect() batching.
    
    function drawExactStar(ctx, x, y, size) {
        ctx.save();
        ctx.translate(x, y);
        // ROTATION: 28 degrees = ~0.488 radians (Counter-Clockwise relative to standard, user wanted this tilt)
        ctx.rotate(28 * Math.PI / 180);
        
        const scale = size / 24; // Source path is 24x24
        ctx.scale(scale, scale);
        ctx.translate(-12, -12);
        
        ctx.beginPath();
        // EXACT SVG PATH provided by User
        ctx.moveTo(12, 0);
        ctx.lineTo(14.59, 9.41);
        ctx.lineTo(24, 12);
        ctx.lineTo(14.59, 14.59);
        ctx.lineTo(12, 24);
        ctx.lineTo(9.41, 14.59);
        ctx.lineTo(0, 12);
        ctx.lineTo(9.41, 9.41);
        ctx.lineTo(12, 0);
        ctx.closePath();
        ctx.fillStyle = "#FFFFFF"; // Mask color
        ctx.fill();
        ctx.restore();
    }
    
    function createParticleGroups() {
        const w = width; // Logical
        const h = height; // Logical
        
        // Temp Canvas for Text Analysis
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const tempCtx = tempCanvas.getContext('2d');
        
        // --- LAYOUT ---
        const mainSize = Math.min(w / 6, 120);
        const startY = h / 2;
        
        // 1. Measure CA
        tempCtx.font = `800 ${mainSize}px "Inter", sans-serif`;
        const caWidth = tempCtx.measureText('CA').width;
        
        // 2. Measure Scribe
        tempCtx.font = `italic 600 ${mainSize}px "Playfair Display", serif`;
        const scribeWidth = tempCtx.measureText('Scribe').width;
        
        // 3. Star Size
        const starSize = mainSize * 0.55; 
        const spacing = mainSize * 0.15;
        
        const totalW = caWidth + spacing + scribeWidth + spacing + starSize;
        const startX = (w - totalW) / 2;
        
        // --- DRAW MASKS ---
        const gCA = [];
        const gScribe = [];
        const gStar = [];
        
        // Mask CA
        tempCtx.clearRect(0,0,w,h);
        tempCtx.font = `800 ${mainSize}px "Inter", sans-serif`;
        tempCtx.fillStyle = '#FFFFFF';
        tempCtx.textBaseline = 'middle';
        tempCtx.fillText('CA', startX, startY);
        let data = tempCtx.getImageData(0,0,w,h).data;
        scan(data, gCA, w, h);
        
        // Mask Scribe
        tempCtx.clearRect(0,0,w,h);
        tempCtx.font = `italic 600 ${mainSize}px "Playfair Display", serif`;
        tempCtx.fillStyle = '#FFFFFF';
        tempCtx.textBaseline = 'middle';
        tempCtx.fillText('Scribe', startX + caWidth + spacing, startY);
        data = tempCtx.getImageData(0,0,w,h).data;
        scan(data, gScribe, w, h);
        
        // Mask Star (Rotated SVG)
        tempCtx.clearRect(0,0,w,h);
        const starCenterX = startX + caWidth + spacing + scribeWidth + spacing + (starSize/2);
        // Slight vertical adjust for star
        drawExactStar(tempCtx, starCenterX, startY - (mainSize*0.1), starSize);
        data = tempCtx.getImageData(0,0,w,h).data;
        scan(data, gStar, w, h);
        
        return { gCA, gScribe, gStar, center: {x: w/2, y: h/2} };
    }
    
    function scan(data, group, w, h) {
        // Step 2 = High Resolution but performant with batching
        const step = 2; 
        for(let y=0; y<h; y+=step) {
            for(let x=0; x<w; x+=step) {
                if(data[(y*w + x)*4 + 3] > 128) {
                    group.push({
                        ox: x, oy: y, // Target Origin
                        x: Math.random() * w, // Current X
                        y: Math.random() * h, // Current Y
                        vx: (Math.random()-0.5)*2,
                        vy: (Math.random()-0.5)*2,
                        s: 1.5 // Size
                    });
                }
            }
        }
    }
    
    // --- 4. ANIMATION LOOP ---
    
    let groups = null;
    let startTime = null;
    let phase = "WAIT"; // WAIT, ASSEMBLE, DONE
    
    function animate(t) {
        if(!groups) {
            requestAnimationFrame(animate);
            return;
        }
        
        ctx.clearRect(0,0,width,height);
        
        // Determine Logic
        if(phase === "WAIT") {
            // Infinite Drift
            updateGroupDrift(groups.gCA, t);
            updateGroupDrift(groups.gScribe, t);
            updateGroupDrift(groups.gStar, t);
        } else if (phase === "ASSEMBLE") {
            if(!startTime) startTime = t;
            const progress = (t - startTime) / 2500; // 2.5s assemble
            updateGroupAssemble(groups.gCA, progress);
            updateGroupAssemble(groups.gScribe, progress);
            updateGroupAssemble(groups.gStar, progress);
            
            if(progress > 1.5) {
                // Done -> Redirect
                window.location.replace(CONFIG.targetUrl);
                return; 
            }
        }
        
        // Batch Draw
        drawGroup(groups.gCA, CONFIG.colors.ca);
        drawGroup(groups.gScribe, CONFIG.colors.scribe);
        drawGroup(groups.gStar, CONFIG.colors.star);
        
        requestAnimationFrame(animate);
    }
    
    function updateGroupDrift(list, t) {
        for(let i=0; i<list.length; i++) {
            const p = list[i];
            p.x += p.vx;
            p.y += p.vy;
            // Wrap
            if(p.x < 0) p.x = width;
            if(p.x > width) p.x = 0;
            if(p.y < 0) p.y = height;
            if(p.y > height) p.y = 0;
            
            // Repel from center text
            const dx = p.x - (width/2);
            const dy = p.y - (height/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 100) {
                 const angle = Math.atan2(dy, dx);
                 p.x += Math.cos(angle) * 5;
                 p.y += Math.sin(angle) * 5;
             }
        }
    }
    
    function updateGroupAssemble(list, progress) {
        const ease = progress > 1 ? 1 : (1 - Math.pow(1 - progress, 3)); // Cubic ease out
        for(let i=0; i<list.length; i++) {
            const p = list[i];
            // Interpolate from current pos to ox/oy is tricky if we don't track start.
            // Simplified: Force move towards target
            const dx = p.ox - p.x;
            const dy = p.oy - p.y;
            p.x += dx * 0.1;
            p.y += dy * 0.1;
        }
    }
    
    function drawGroup(list, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for(let i=0; i<list.length; i++) {
            ctx.rect(list[i].x, list[i].y, list[i].s, list[i].s);
        }
        ctx.fill();
    }
    
    // --- 5. INIT & SERVER CHECK ---
    
    document.fonts.ready.then(() => {
        setTimeout(() => {
            groups = createParticleGroups();
            requestAnimationFrame(animate);
            checkServer();
        }, 100);
    });
    
    function checkServer() {
        if(phase !== "WAIT") return;
        
        fetch(CONFIG.healthUrl).then(r => {
            if(r.ok) {
                phase = "ASSEMBLE";
                document.getElementById('loading-label').style.opacity = 0;
            } else {
                setTimeout(checkServer, CONFIG.pingInterval);
            }
        }).catch(() => setTimeout(checkServer, CONFIG.pingInterval));
    }
  </script>
</body>

</html>